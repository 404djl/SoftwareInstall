## 修改切片副本是否影响原切片
在 Go 中，当你复制一个切片（即创建切片的副本）后修改副本，**原切片是否会被修改取决于修改的操作类型**，核心原因是切片的底层结构特性：

### 1. 切片的底层结构
切片本质是一个包含三个字段的结构体：
- 指向底层数组的指针（`ptr`）
- 切片的长度（`len`）
- 切片的容量（`cap`）

当你复制一个切片时（例如 `newSlice := oldSlice`），复制的是这个结构体的**副本**，但副本和原切片的 `ptr` 字段指向**同一个底层数组**。


### 2. 两种修改场景的不同结果
#### 场景1：修改副本的「元素值」→ 原切片会被影响
如果通过副本修改底层数组中的元素值，由于原切片和副本共享同一个底层数组，原切片的对应元素会同步变化。

示例：
```go
package main

import "fmt"

func main() {
    oldSlice := []int{1, 2, 3, 4}
    newSlice := oldSlice // 复制切片（结构体副本，共享底层数组）

    newSlice[0] = 100 // 修改副本的元素

    fmt.Println("原切片:", oldSlice) // 输出：原切片: [100 2 3 4]
    fmt.Println("副本切片:", newSlice) // 输出：副本切片: [100 2 3 4]
}
```

#### 场景2：修改副本的「长度或容量」（如 append 导致扩容）→ 原切片不受影响
如果对副本执行 `append` 等操作，且操作后超出了原底层数组的容量（`cap`），Go 会为副本**新建一个底层数组**，此时副本与原切片的底层数组分离，后续修改副本的元素不会影响原切片。

示例：
```go
package main

import "fmt"

func main() {
    oldSlice := []int{1, 2, 3} // len=3, cap=3（底层数组容量为3）
    newSlice := oldSlice       // 复制切片，共享底层数组

    // 对副本执行append，超出原容量（3），触发扩容（新建底层数组）
    newSlice = append(newSlice, 4)
    newSlice[0] = 100 // 修改副本的元素

    fmt.Println("原切片:", oldSlice) // 输出：原切片: [1 2 3]（不受影响）
    fmt.Println("副本切片:", newSlice) // 输出：副本切片: [100 2 3 4]
}
```


### 3. 关键结论
- 复制切片时，副本与原切片**共享底层数组**（除非副本扩容）。
- 若修改副本的**元素值**且未触发扩容 → 原切片会被修改。
- 若修改副本导致**扩容**（底层数组更换） → 原切片不受影响。
- 若仅修改副本的**长度**（如 `newSlice = newSlice[:2]`），不涉及元素或扩容 → 原切片长度不变（因为长度是切片结构体的字段，副本和原切片的结构体是独立的）。


### 扩展：如何彻底隔离原切片和副本？
如果希望复制后的切片与原切片完全独立（修改副本绝对不影响原切片），可以通过**显式创建新的底层数组**实现，例如使用 `copy` 函数：
```go
oldSlice := []int{1, 2, 3}
newSlice := make([]int, len(oldSlice)) // 新建一个同长度的切片
copy(newSlice, oldSlice) // 将原切片元素复制到新切片的底层数组

newSlice[0] = 100 // 修改副本，原切片不受影响
fmt.Println(oldSlice) // [1 2 3]
```

此时，`newSlice` 拥有独立的底层数组，无论如何修改都不会影响 `oldSlice`。
