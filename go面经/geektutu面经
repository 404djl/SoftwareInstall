### Go基础语法

1. `=` 和 `:=` 的区别？

   - `=` 是赋值操作符，用于给已声明的变量赋值
   - `:=` 是短变量声明，用于声明并初始化变量，只能在函数内部使用
   - 示例：`var a int; a = 5` 等价于 `a := 5`

2. 指针的作用

   - 指向变量的内存地址，允许直接修改内存中的值
   - 减少值传递时的内存拷贝，提高性能
   - 实现引用类型的行为，用于函数参数传递时修改外部变量
   - 支持数据结构中的链接关系（如链表、树）

3. Go 允许多个返回值吗？

   - 是的，Go函数支持返回多个值
   - 常用于返回结果和错误信息，如 `result, err := function()`
   - 可以给返回值命名，提高代码可读性

4. Go 有异常类型吗？

   - Go没有传统意义上的异常类型（如Java的Exception）
   - 使用多返回值返回错误信息（通常最后一个返回值为error类型）
   - 提供`panic`和`recover`机制处理严重错误，但不建议用于常规错误处理

5. 什么是协程（Goroutine）

   - 轻量级线程，由Go运行时管理而非操作系统
   - 启动成本低，可以创建大量并发任务
   - 使用`go`关键字启动：`go function()`
   - 通过通道（channel）进行通信，实现"不要通过共享内存通信，而要通过通信共享内存"

6. 如何高效地拼接字符串

   - 使用`strings.Builder`（推荐），效率最高

   - 或使用`bytes.Buffer`

   - 避免使用`+`拼接大量字符串，会产生很多临时对象

   - 示例：

     ```go
     var builder strings.Builder
     builder.WriteString("hello")
     builder.WriteString("world")
     result := builder.String()
     ```

7. 什么是 rune 类型

   - 是`int32`的别名，用于表示Unicode码点
   - 用于处理中文、日文等多字节字符
   - 在遍历字符串时，`for range`循环会将字符串转换为rune序列

8. 如何判断 map 中是否包含某个 key ？

   - 使用双返回值形式：`value, exists := map[key]`
   - `exists`是布尔值，true表示存在该key，false表示不存在

9. Go 支持默认参数或可选参数吗？

   - 不支持
   - 替代方案：使用结构体传递参数、函数重载（通过不同函数名）或可变参数

10. defer 的执行顺序

    - defer语句在函数返回前执行
    - 多个defer按后进先出（LIFO）顺序执行
    - 常用于资源释放、关闭连接等清理操作

11. 如何交换 2 个变量的值？

    - 可以直接交换，不需要临时变量：`a, b = b, a`

12. Go 语言 tag 的用处？

    - 用于给结构体字段添加元数据
    - 常用于JSON/XML序列化、数据库映射等场景
    - 示例：`json:"name" db:"username"`

13. 如何判断 2 个字符串切片（slice) 是相等的？

    - 需要手动判断长度是否相等，然后逐个元素比较
    - 或使用`reflect.DeepEqual(a, b)`，但性能较差
    - 注意：切片本身不支持`==`直接比较

14. 字符串打印时，%v 和 %+v 的区别

    - `%v` 按默认格式打印值
    - `%+v` 打印结构体时会包含字段名

15. Go 语言中如何表示枚举值(enums)？

    - 没有专门的枚举类型，通常使用`iota`实现

    - 示例：

      ```go
      type Status int
      const (
          Pending Status = iota  // 0
          Active                 // 1
          Inactive               // 2
      )
      ```

16. 空 struct{} 的用途

    - 作为通道元素类型，用于传递信号（不需要实际数据）
    - 作为map的值类型，表示集合（只关注key）
    - 空结构体不占用内存空间，可节省内存
    - 示例：`done := make(chan struct{})` 用于协程间通信信号

### Go实现原理

1. **init() 函数是什么时候执行的？**

   - init()函数在包被导入时自动执行，执行顺序在main()函数之前
   - 执行顺序：先初始化包级变量，再执行init()函数
   - 同一个包中可以有多个init()函数，按出现顺序执行
   - 不同包的init()函数按包导入依赖关系执行

2. **Go 语言的局部变量分配在栈上还是堆上？**

   - 由Go编译器的逃逸分析决定，不固定分配在栈或堆上
   - 若变量仅在函数内部使用（未逃逸），通常分配在栈上
   - 若变量被外部引用（发生逃逸），则分配在堆上
   - 栈上分配效率更高，会随函数退出自动释放；堆上分配需要GC回收

3. **2 个 interface 可以比较吗？**

   - 可以比较，但有条件限制：
   - 当两个interface都为nil时，相等
   - 当它们的动态类型相同且动态值可比较时，可以比较
   - 若动态类型相同但动态值不可比较（如slice、map等），比较会触发panic
   - 动态类型不同的interface比较结果为false

4. **2 个 nil 可能不相等吗？**

   - 可能不相等

   - 当两个nil分别属于不同静态类型的interface时，它们不相等

   - 示例：

     ```go
     var a *int = nil
     var b interface{} = nil
     fmt.Println(a == b)  // 输出 false
     ```

   - 原因是interface包含类型和值两部分，a的类型是*int，b的类型是nil

5. **简述 Go 语言GC(垃圾回收)的工作原理**

   - Go采用并发标记-清除算法，结合三色标记法
   - 基本流程：
     1. 标记阶段：从根对象出发，标记所有可达对象
     2. 清除阶段：回收未被标记的对象，释放内存
     3. 整理阶段：（可选）整理内存碎片
   - 采用写屏障技术，允许标记过程与用户程序并发执行
   - Go 1.8引入混合写屏障，大幅减少STW（Stop The World）时间
   - 支持并发清理，进一步降低对程序运行的影响

6. **函数返回局部变量的指针是否安全？**

   - 安全

   - Go编译器会通过逃逸分析，将被外部引用的局部变量分配到堆上

   - 即使变量在函数内定义，只要有指针被返回，就会逃逸到堆上

   - 示例：

     ```go
     func getPtr() *int {
         x := 10
         return &x  // 安全，x会被分配到堆上
     }
     ```

7. **非接口类型 T 都能够调用 *T 的方法吗？反过来呢？**

   - T类型的值可以调用*T的方法，前提是该值可寻址

   - Go会自动将T转换为*T来调用其方法（隐式取地址）

   - 反过来，*T类型可以调用T的方法，因为指针类型可以解引用为值类型

   - 例外：当方法接收器是*T，而T是不可寻址的（如常量、临时变量），则不能调用

   - 示例：

     ```go
     type T int
     func (t *T) Inc() { *t++ }
     
     func main() {
         var a T = 5
         a.Inc()  // 合法，a可寻址，自动转换为&a
         
         b := &a
         b.Inc()  // 合法，*T可以调用*T的方法
         
         // T(5).Inc()  // 不合法，临时变量不可寻址
     }
     ```

### 并发编程

1. **无缓冲的 channel 和有缓冲的 channel 的区别？**
   - **无缓冲channel**：
     - 发送操作（send）会阻塞，直到有对应的接收操作（receive）完成
     - 接收操作会阻塞，直到有对应的发送操作完成
     - 本质是同步通信，发送方和接收方必须同时准备好
     - 声明方式：`ch := make(chan int)`

   - **有缓冲channel**：
     - 当缓冲区未满时，发送操作不会阻塞；缓冲区满时，发送操作阻塞
     - 当缓冲区非空时，接收操作不会阻塞；缓冲区空时，接收操作阻塞
     - 本质是异步通信，发送方和接收方可在不同时间点操作
     - 声明方式：`ch := make(chan int, 10)`（缓冲区大小为10）

   - 核心区别：无缓冲channel实现同步通信，有缓冲channel实现异步通信，缓冲大小决定了可暂存的元素数量。

2. **什么是协程泄露(Goroutine Leak)？**
   - 指创建的goroutine在完成预期工作后没有退出，仍然占用系统资源（内存、线程等）的现象
   - 常见原因：
     - goroutine在等待永远不会到达的channel数据
     - 错误使用互斥锁导致死锁，goroutine无法继续执行
     - 循环条件错误导致goroutine无限运行
     - 未正确处理退出信号，导致goroutine无法终止
   - 危害：随着泄露的goroutine增多，会消耗大量内存和CPU资源，最终可能导致程序崩溃
   - 避免方法：确保每个goroutine都有明确的退出条件，使用带超时的channel操作，通过context控制goroutine生命周期等

3. **Go 可以限制运行时操作系统线程的数量吗？**
   - 可以，通过`runtime.GOMAXPROCS(n)`函数限制
   - 该函数设置可同时执行用户级任务的操作系统线程（逻辑处理器）的最大数量
   - 在Go 1.5之前，默认值为1；Go 1.5及之后，默认值为CPU核心数
   - 示例：`runtime.GOMAXPROCS(4)` 限制最多使用4个操作系统线程
   - 注意：这是对逻辑处理器数量的限制，实际创建的操作系统线程可能更多（如处理系统调用的线程），但用户级goroutine的并行执行数量不会超过该值
   - 合理设置该值可以避免过多线程切换带来的开销，优化程序性能

